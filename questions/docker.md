#### 1.Docker的运行原理

Docker运行容器依赖操作系统内核的技术，通过对Namespace、Cgroups、UnionFS的组合应用，实现了容器化技术。

其中Namespace包括对PID、NET、IPC、UTS和MOUNT的隔离；Cgroups通过对进程的资源限制控制容器的资源使用；UnionFS实现了镜像的分层存储。

Docker是一个C/S架构的应用，用户通过客户端工具发送指令，守护进程`dockerd`运行在后台，负责管理容器的生命周期。

当用户通过客户端下发创建容器的指令时，客户端将请求发送给守护进程，守护进程根据镜像名称检查本地是否存在该镜像，如果不存在就会去远端的镜像仓库拉取镜像到本地。镜像准备妥当后，借助Namespace技术为容器创建隔离的运行环境，如果配置中包含init容器，则会先逐个启动init容器完成初始化操作，完成后退出并启动主容器，主容器进程读取启动命令和环境参数，在预设条件下开始运行。

#### 2.Docker和Containerd有什么不同

背景：Docker在重构后把负责容器生命周期管理的部分从Dockerd分离出来并在2017年捐赠给CNCF，两者都是高级容器运行时，默认的底层容器运行时都是`runc`，`runc`符合OCI规范，由`libcontainer`发展而来，直接负责和底层操作系统的交互。

Docker为用户提供了易用的命令行和API，使用更加简单，同时Docker会依赖Containerd的能力，除了基本的运行时能力外还集成了镜像、网络、存储等功能模块。

Containerd是目前更加主流的容器化工具，命令行工具有`ctr/crictl/nerdctl`，专注于运行时管理，负责容器的生命周期操作，不涉及如镜像构建和容器编排等功能，架构设计更为轻量化和模块化，可以与不同的低级容器运行时结合，易于集成和扩展。

#### 3.容器的本质是什么

容器本质上是使用操作系统内核的`cgroups`、`namespace`等特性的一种特殊的进程。

容器镜像基于联合文件系统构建，由多个只读层组成。启动容器时将只读层和可写层联合挂载形成完整的文件系统。

它拥有独立的工作空间，直接共享主机的内核，比传统的虚拟化技术更轻量，可以显著提高资源的利用效率，在相同的硬件资源上可以运行更多实例。

遵循OCI的标准化镜像可以在不同操作系统的发行版上运行，可移植性强，不依赖特定宿主机。

#### 4.Dockerfile命令CMD/ENTRYPOINT和ADD/COPY的作用和区别

`CMD`和`ENTRYPOINT`都用与指定容器启动时的命令，如果容器启动时没有其他命令传入，`CMD`中的命令就会被执行，但`CMD`中的命令会被`docker run`中的命令覆盖，而`ENTRYPOINT`中的命令一般不会被覆盖，如果要覆盖需要指定flag`--entrypoint`才会改变。 一般`CMD`常用于指定默认参数，可以被容器的启动命令修改，而`ENTRYPOINT`用于执行类似命令行操作的指令。

`ADD`和`COPY`都用于将文件从主机复制到容器目录中，区别在于如果是压缩包`ADD`会自动解压，而且`ADD`还可以复制远端的URL资源，而`COPY`只能复制宿主机文件。由于网络等原因，`COPY`只涉及本地文件和复制操作，在镜像构建过程中更可靠。

#### 5.Containerd中一个容器是如何被拉起的

1.客户端向服务端守护进程发起创建请求；

2.Containerd准备镜像，镜像的层存储在`content store`中；

3.基于已存在的只读层镜像，创建新的可写层并联合挂载组成完整的文件系统视图；

4.创建`contianer`对象，包含容器的各种配置信息；

5.启动`containerd-shim`进程，`containerd-shim`调用`runc`创建并启动`task`；

6.`task`完成容器运行环境的初始化后启动容器进程并管理容器的生命周期；

#### 6.如何优化构建镜像的体积

1.使用合适的官方基础镜像，如`alpine`，通常能够显著减小镜像体积，同时减少不必要的软件包安装;

2.构建过程中合并命令以减少中间层;

3.软件包安装后清理缓存，如`RUN apt-get clean && rm -rf /var/lib/apt/lists/`;

4.移除业务代码中未被使用的依赖；

5.分阶段构建，使用多个`FROM`命令，把编译环境和运行环境分离；

6.合理安排指令顺序，实现层的复用；

#### 7.容器网络类型都有哪些

1.bridge：容器默认网络模式，由挂载在docker0和容器内部的veth-pair实现。

2.host：容器直接使用宿主机的网络栈，不创建独立的网络命名空间。

3.container：和已创建的容器共享网络命名空间，适用于紧密协作的容器，Pod中容器使用的就是container模式共享pause容器创建的网络栈。

4.none：没有任何网络配置。

#### 8.多阶段构建的好处

1.能有效减小镜像的体积，精简镜像文件内容；

2.使dockerfile更清晰可维护；

3.如果多个任务之间没有依赖关系，可以并行构建以提高镜像构建速度；

4.减少不必要的依赖，提高镜像安全性；

#### 9.容器日志管理方式

1.标准化输出；

2.容器内存储；

3.持久化到宿主机；

4.集中式存储ELK；

5.云原生日志服务；

#### 10.多进程服务如nginx是否符合容器最佳实践

符合容器化最佳实践，容器是一个单进程模型，但不是说容器内只能运行一个进程，PID为1的主进程关联容器的生命周期，容器运行时也主要通过和主进程的交互来控制容器状态。

Nginx采用的是`master-worker`进程模型，其中`master`进程负责启动和管理`worker`进程，实际的请求由`worker`进程处理。在容器化的Nginx中`master`作为主进程，当收到停止信号时会负责停止`worker`进程并完成容器停止退出需要的操作，这种设计使容器中运行的多个进程符合单进程管理模型。

其次，在资源隔离方面，容器的资源是对整个Nginx进程组统一生效的，镜像与部署也符合容器化的最佳实践，但也可能存在对`worker`进程的健康检查和日志监控方面的挑战。

#### 11.