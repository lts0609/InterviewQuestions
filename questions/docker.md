#### 1.Docker的运行原理

Docker运行容器依赖操作系统内核的技术，通过对Namespace、Cgroups、UnionFS的组合应用，实现了容器化技术。

其中Namespace包括对PID、NET、IPC、UTS和MOUNT的隔离；Cgroups通过对进程的资源限制控制容器的资源使用；UnionFS实现了镜像的分层存储。

Docker是一个C/S架构的应用，用户通过客户端工具发送指令，守护进程`dockerd`运行在后台，负责管理容器的生命周期。

当用户通过客户端下发创建容器的指令时，客户端将请求发送给守护进程，守护进程根据镜像名称检查本地是否存在该镜像，如果不存在就会去远端的镜像仓库拉取镜像到本地。镜像准备妥当后，借助Namespace技术为容器创建隔离的运行环境，如果配置中包含init容器，则会先逐个启动init容器完成初始化操作，完成后退出并启动主容器，主容器进程读取启动命令和环境参数，在预设条件下开始运行。

#### 2.Docker和Containerd有什么不同

背景：Docker在重构后把负责容器生命周期管理的部分从Dockerd分离出来并在2017年捐赠给CNCF，两者都是高级容器运行时，默认的底层容器运行时都是`runc`，`runc`符合OCI规范，由`libcontainer`发展而来，直接负责和底层操作系统的交互。

Docker为用户提供了易用的命令行和API，使用更加简单，同时Docker会依赖Containerd的能力，除了基本的运行时能力外还集成了镜像、网络、存储等功能模块。

Containerd是目前更加主流的容器化工具，专注于运行时管理，负责容器的生命周期操作，不涉及如镜像构建和容器编排等功能，架构设计更为轻量化和模块化，可以与不同的低级容器运行时结合，易于集成和扩展。

#### 3.容器的本质是什么

容器本质上是使用操作系统内核的`cgroups`、`namespace`等特性的一种特殊的进程。

容器镜像基于联合文件系统构建，由多个只读层组成。启动容器时将只读层和可写层联合挂载形成完整的文件系统。

它拥有独立的工作空间，直接共享主机的内核，比传统的虚拟化技术更轻量，可以显著提高资源的利用效率，在相同的硬件资源上可以运行更多实例。

遵循OCI的标准化镜像可以在不同操作系统的发行版上运行，可移植性强，不依赖特定宿主机。

#### 4.Dockerfile命令CMD/ENTRYPOINT和ADD/COPY的作用和区别

`CMD`和`ENTRYPOINT`都用与指定容器启动时的命令，如果容器启动时没有其他命令传入，`CMD`中的命令就会被执行，但`CMD`中的命令会被`docker run`中的命令覆盖，而`ENTRYPOINT`中的命令一般不会被覆盖，如果要覆盖需要指定flag`--entrypoint`才会改变。 一般`CMD`常用于指定默认参数，可以被容器的启动命令修改，而`ENTRYPOINT`用于执行类似命令行操作的指令。

`ADD`和`COPY`都用于将文件从主机复制到容器目录中，区别在于如果是压缩包`ADD`会自动解压，而且`ADD`还可以复制远端的URL资源，而`COPY`只能复制宿主机文件。由于网络等原因，`COPY`只涉及本地文件和复制操作，在镜像构建过程中更可靠。

#### 5.Docker的三大核心原理



#### 6.如何优化构建镜像的体积



#### 7.容器网络类型



#### 8.多阶段构建的好处



#### 9.容器日志管理方式



#### 10.多进程服务如nginx是否符合容器最佳实践



#### 11.